Сделать папку репозиторием — git init

Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать 
Git-репозиторием (от англ. repository — «хранилище»). Для этого следует переместиться в неё и ввести 
команду git init (от англ. initialize — «инициализировать»).
Например, создайте папку first-project и сделайте её Git-репозиторием: перейдите в неё с помощью 
команды cd и выполните git init.

$ cd ~/dev/first-project # перешли в нужную папку

$ git init # создали репозиторий

git init выведет сообщение вида Initialized empty Git repository in <*ваша папка с проектом*>/.git/ 
(англ. «инициализирован пустой Git-репозиторий в <*ваша папка*>/.git/»). В подпапке .git Git будет хранить 
всю служебную информацию.


«Разгитить» папку, если что-то пошло не так, — rm -rf .git

Если вы случайно сделали Git-репозиторием не ту папку, её можно «разгитить». Для этого нужно удалить 
скрытую подпапку .git.

$ cd <папка с репозиторием> # перешли в папку

$ rm -rf .git # удалили подпапку .git

Разберём подробнее, что такое -rf:
ключ -r (от англ. recursive — «рекурсивно») позволяет удалять папки вместе с их содержимым;
ключ -f (от англ. force — «заставить») избавит вас от лишних вопросов.


Проверить состояние репозитория — git status

После инициализации репозитория first-project запустите команду git status (от англ. status — «статус», «состояние») 
— она показывает текущее состояние репозитория.

Команда git status выведет:
 - название текущей ветки: On branch master или On branch main;
 - сообщение о том, что в репозитории ещё нет коммитов: No commits yet;
 - сообщение, которое говорит: «чтобы что-нибудь закоммитить (то есть зафиксировать), нужно сначала это 
создать» — nothing to commit (create/copy files and use "git add" to track).


Подготовить файлы к сохранению — git add

Добавим в репозиторий два файла. Например, файл todo.txt, в котором будет список дел, и readme.txt для информации о проекте.

$ touch todo.txt

$ touch readme.txt

# создали файлы todo.txt и readme.txt

$ git status # проверили статус

Git сообщит, что в папке first-project есть untracked files (от англ. track — «следить», untracked — «неотслеженный», 
«неотслеживаемый») — ещё не отслеживаемые файлы readme.txt и todo.txt.

Состояние untracked значит, что Git ещё не хранит информацию о версиях файла и не может отследить, как он изменялся.
Сейчас в first-project два файла. Мы хотим отслеживать состояние обоих, поэтому можем использовать команду git add --all 
(от англ. add — «добавить» + от англ. all — «всё»). Ключ, или флаг, --all позволяет подготовить к сохранению все файлы 
в репозитории.

$ git add --all # подготовили к сохранению все файлы в репозитории

$ git status # проверили статус 

Добавлять файлы можно и по одному, без ключа --all.

$ git add todo.txt

$ git add readme.txt

$ git status 

Также можно добавить текущую папку целиком — в этом случае все файлы в ней тоже будут добавлены. Обратиться к текущей 
папке в Bash позволяет точка (.).

$ git add . # добавить всю текущую папку

$ git status 

Вы можете использовать любой из этих вариантов — результат будет одинаковый.

Если сейчас отредактировать любой из «зелёных» файлов в папке first-project, он перейдёт в состояние modified 
(англ. «изменённый») и будет и в «зелёном», и в «красном» списках. 

Команда git add позволяет подготовить файл к сохранению.
Команда git add --all подготовит к сохранению сразу все файлы.
С помощью git add . можно добавить в репозиторий текущую папку со всеми файлами.


Выполнить коммит — git commit

Сделать коммит можно командой git commit c ключом -m (от англ. message — «сообщение»), который присваивает 
коммиту сообщение.

$ git commit -m "Мой первый коммит!"

Команда git commit выведет информацию о коммите.
[master (root-commit) baa3b6e] значит - коммит был в ветке master;
root-commit — это самый первый, или «корневой» (англ. root), коммит в ветке, у следующих коммитов такой надписи не будет;
baa3b6e — сокращённый идентификатор коммита (подробнее об этом мы ещё расскажем).
2 files changed, 1 insertion(+) значит - изменились два файла (readme.txt и todo.txt);
одна строка была добавлена;
Строки вида create mode 100644 readme.txt — это более подробная информация о новых (добавленных в Git) файлах.
create (англ. «создать») говорит, что файл был создан. Если бы файл был удалён, на этом месте было бы 
слово delete (англ. «удалить»).
mode 100644 сообщает, что это обычный файл. Также возможны варианты 100755 для исполняемых файлов (например, что-нибудь.exe) 
и 120000 для файлов-ссылок в Linux. Файлы-ссылки не содержат данных сами по себе, а только ссылаются 
на другие файлы — как «ярлыки» в Windows.


Просмотреть историю коммитов — git log

В самостоятельном задании прошлого урока вы сделали три коммита в ваш репозиторий. Чтобы увидеть их все, введите 
команду git log (от англ. log — «журнал [записей]»).

SSH

Настройка доступа по SSH ключу в GitHub в Windows и MacOS

https://best-manual.ru/blog/diy/2022-11-21-nastrojka-dostupa-po-ssh-klyuchu-v-github-v-windows-i-macos.html


Привязать удалённый репозиторий к локальному — git remote add

Перейдите на страницу удалённого репозитория, выберите тип SSH и скопируйте URL. Кнопка справа позволит сделать это мгновенно.

Откройте консоль, перейдите в каталог локального репозитория и введите команду git remote add (от англ. remote — «удалённый» 
и add — «добавить»).

$ cd ~/dev/first-project

$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git 

Команде необходимо передать два параметра: имя удалённого репозитория и его URL. В качестве имени используйте слово origin. 
А URL вы скопировали со страницы удалённого репозитория.

Убедиться, что репозитории связаны, — git remote -v

Отлично: вы связали локальный репозиторий с удалённым. Осталось убедиться, что всё работает, с помощью следующей команды.

$ git remote -v

origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push) 

В выводе вы должны увидеть две строчки, аналогичные тем, что показаны выше.

Флаг -v — короткая форма флага --verbose (англ. «подробный»). Он позволяет показать больше информации в выводе.


Отправить изменения на удалённый репозиторий — git push

В первый раз эту команду нужно вызвать с флагом -u и параметрами origin (имя удалённого репозитория) и main 
или master (название текущей ветки). Флаг -u свяжет локальную ветку с одноимённой удалённой. Как вы связывали 
локальный и удалённый репозитории в предыдущем уроке, так же и здесь нужно дополнительно связать ветки.

$ git push -u origin main # Если команда приведёт к ошибке, попробуйте 
                          # заменить main на master. 


Получить сокращённый лог — git log --oneline

Получить сокращённый лог можно с помощью команды git log с флагом --oneline (англ. «одной строкой»). 
В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии.

Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. 
Для этого команда git log --oneline автоматически подбирает такую длину сокращённых хешей, чтобы они были 
уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.

Если выход из просмотра логов не произошёл автоматически, нажмите клавишу Q (от англ. Quit — «выйти») в английской 
раскладке клавиатуры.


Файл HEAD
Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, 
который сделан последним (то есть на самый новый).

Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки). 
Если заглянуть в этот файл, можно увидеть хеш последнего коммита.

$ cat refs/heads/master # взяли ссылку из файла HEAD
# внутри хеш
e007f5035f113f9abca78fe2149c593959da5eb7

Когда вы делаете коммит, Git обновляет refs/heads/master — записывает в него хеш последнего коммита. 
Получается, что HEAD тоже обновляется, так как ссылается на refs/heads/master.
При работе с Git указатель HEAD используется довольно часто. Мы уже упоминали, что многие команды 
Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша 
можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.

Статусы untracked/tracked, staged и modified

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается 
каким-либо статусом. Рассмотрим основные.

untracked (англ. «неотслеживаемый»)

Мы говорили, что новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. 
Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет 
предыдущих версий, зафиксированных в коммитах или через команду git add.

staged (англ. «подготовленный»)

После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» 
и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится 
в состоянии staged.

Staging area, index и cache
Staging area также называют index (англ. «каталог») или cache (англ. «кеш»), а состояние файла staged 
иногда называют indexed или cached.
Все три варианта могут встречаться в документации и в качестве флагов команд Git. 

tracked (англ. «отслеживаемый»)

Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, 
которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area 
командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.

modified (англ. «изменённый»)

Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. 
Например, файл был закоммичен и после этого изменён.
Для файлов в состояниях staged и modified обычно не указывают, что они также tracked, потому что 
это состояние подразумевается.

Про staged и modified

Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, 
сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging.
Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging. 
Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз.

В Git файлы могут находиться в разных состояниях: untracked, staged, modified, tracked.
Untracked: новые файлы, не отслеживаемые Git.
Staged: файлы после git add, в списке для коммита.
Modified: файлы с изменениями относительно последней версии в staging.
Tracked: файлы, отслеживаемые Git, включая фиксированные и добавленные в staging.


Какие состояния показывает git status

Большинство файлов в типичном проекте будут находиться в состоянии tracked (то есть закоммичены и не изменены 
после коммита). Вы не увидите это состояние в выводе команды git status — иначе она бы каждый раз выводила 
список вообще всех файлов проекта.

В итоге git status показывает только следующие состояния файлов:

staged (Changes to be committed в выводе git status);

modified (Changes not staged for commit);

untracked (Untracked files).


Типичные варианты вывода git status: без изменений, с найденными неотслеживаемыми файлами, с изменениями, 
которые не войдут в коммит, и с изменениями, которые уже попали в коммит.
В случае изменений файла, git status может показать его состояние как "staged" и "modified".

















